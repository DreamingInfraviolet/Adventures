import org.antlr.v4.runtime.tree.TerminalNode;

import com.sun.xml.internal.bind.v2.schemagen.xmlschema.List;

public class CustomVisitor<T> extends FabulaBaseVisitor<T>
{
	private Section mBase = new Section("base",null); //base, represented by the null location
	private Section mCurrentSection = mBase;
	private Scene mCurrentScene = null;
	private ChoiceList mCurrentChoiceList = null;
	private Choice mCurrentChoice = null;
	
	public CompilationException error = null;

	public CustomVisitor()
	{
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitProg(FabulaParser.ProgContext ctx)
	{ 
		return visitChildren(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitSectionContent(FabulaParser.SectionContentContext ctx)
	{ 
		return visitChildren(ctx);
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitSection(FabulaParser.SectionContext ctx)
	{ 
		String name = ctx.IDENTIFIER().getText();
		Section newSection = new Section(ctx.IDENTIFIER().getText(), mCurrentSection);
		mCurrentSection.addSection(newSection);
		Section lastSection = mCurrentSection;
		mCurrentSection = newSection;
		T out = visitChildren(ctx);
		mCurrentSection = lastSection;
		return out;
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitScene(FabulaParser.SceneContext ctx)
	{ 
		//construct scene
		TerminalNode name = ctx.IDENTIFIER();
		Scene scene = new Scene(name.getText());
		mCurrentSection.addScene(scene);
		
		//backup current scene
		Scene lastScene = mCurrentScene;
		mCurrentScene = scene;
		
		//analyse scene using current scene
		T out = visitChildren(ctx);
		
		//restore current scene
		mCurrentScene = lastScene;
		return out;
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitSceneContent(FabulaParser.SceneContentContext ctx)
	{ 
		//initialise strings in scene
		FString[] fStrings = new FString[ctx.STRING().size()];
		for (int i = 0; i < fStrings.length; ++i)
			fStrings[i] = new FString(ctx.STRING().get(i).getText());
		
		//Initialise choice list
		ChoiceList choiceList = new ChoiceList();
		ChoiceList lastChoiceList = mCurrentChoiceList;
		mCurrentChoiceList = choiceList;
		
		//populate choicelist
		T out =  visitChildren(ctx);
		
		//finish up
		mCurrentChoiceList = lastChoiceList;
		
		mCurrentScene.setSceneContent(fStrings, choiceList);
		
		return out;
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitChoicelist(FabulaParser.ChoicelistContext ctx)
	{ 
		//visit every choice
		for(int i = 0; i < ctx.choice().size(); ++i)
			visit(ctx.choice().get(i).getRuleContext());
		return null;
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitChoice(FabulaParser.ChoiceContext ctx)
	{ 
		Choice choice = new Choice(new FString(ctx.STRING()==null ? "":ctx.STRING().getText()),
								   new FString(ctx.choicerhs().STRING().getText()));
		mCurrentChoiceList.addChoice(choice);
		mCurrentChoice = choice;
		
		//populate scene location
		T out = visitChildren(ctx);
		mCurrentChoice = null;
		return out;
	}

	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 * @throws CompilationException 
	 */
	@Override public T visitSceneLocation(FabulaParser.SceneLocationContext ctx)
	{ 
		SectionLocation location = new SectionLocation();
		mCurrentChoice.setSceneLocation(location);
		
		//climb tree and add sections
		
		//if prefix arrow exists, use base as staritng point.
		if(!ctx.prefixArrow()!=null)
			location.addLocationToBack(mBase);
		else //use current location as starting point
			location.addLocationToBack(mCurrentSection);
		
		//add any sections
		Section currentSec = mCurrentSection;
		for(int i = 0; i < ctx.IDENTIFIER().size()-1; ++i)
		{
			currentSec = currentSec.findSectionInSection(ctx.IDENTIFIER(i).getText());
			if(currentSec == null)
			{
				error = new CompilationException("Invalid scene location: " + ctx.IDENTIFIER(i).getText() + " does not exist.", 
						ctx.IDENTIFIER(i).getSymbol().getLine(),
						ctx.IDENTIFIER(i).getSymbol().getCharPositionInLine());
				return null;
			}
			
			location.addLocationToBack(currentSec);
		}
		
		location.setScene(currentSec.findSceneInSection(ctx.IDENTIFIER(ctx.IDENTIFIER().size()-1).getText()));
	

	
		return visitChildren(ctx);
	}

}